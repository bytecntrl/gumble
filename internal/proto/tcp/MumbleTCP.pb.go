// Copyright The Mumble Developers. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file at the root of the
// Mumble source tree or at <https://www.mumble.info/LICENSE>.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.31.1
// source: MumbleTCP.proto

package tcp

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Reject_RejectType int32

const (
	// The rejection reason is unknown (details should be available
	// in Reject.reason).
	Reject_None Reject_RejectType = 0
	// The client attempted to connect with an incompatible version.
	Reject_WrongVersion Reject_RejectType = 1
	// The user name supplied by the client was invalid.
	Reject_InvalidUsername Reject_RejectType = 2
	// The client attempted to authenticate as a user with a password but it
	// was wrong.
	Reject_WrongUserPW Reject_RejectType = 3
	// The client attempted to connect to a passworded server but the password
	// was wrong.
	Reject_WrongServerPW Reject_RejectType = 4
	// Supplied username is already in use.
	Reject_UsernameInUse Reject_RejectType = 5
	// Server is currently full and cannot accept more users.
	Reject_ServerFull Reject_RejectType = 6
	// The user did not provide a certificate but one is required.
	Reject_NoCertificate     Reject_RejectType = 7
	Reject_AuthenticatorFail Reject_RejectType = 8
	// The server is currently not accepting new connections
	Reject_NoNewConnections Reject_RejectType = 9
)

// Enum value maps for Reject_RejectType.
var (
	Reject_RejectType_name = map[int32]string{
		0: "None",
		1: "WrongVersion",
		2: "InvalidUsername",
		3: "WrongUserPW",
		4: "WrongServerPW",
		5: "UsernameInUse",
		6: "ServerFull",
		7: "NoCertificate",
		8: "AuthenticatorFail",
		9: "NoNewConnections",
	}
	Reject_RejectType_value = map[string]int32{
		"None":              0,
		"WrongVersion":      1,
		"InvalidUsername":   2,
		"WrongUserPW":       3,
		"WrongServerPW":     4,
		"UsernameInUse":     5,
		"ServerFull":        6,
		"NoCertificate":     7,
		"AuthenticatorFail": 8,
		"NoNewConnections":  9,
	}
)

func (x Reject_RejectType) Enum() *Reject_RejectType {
	p := new(Reject_RejectType)
	*p = x
	return p
}

func (x Reject_RejectType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Reject_RejectType) Descriptor() protoreflect.EnumDescriptor {
	return file_MumbleTCP_proto_enumTypes[0].Descriptor()
}

func (Reject_RejectType) Type() protoreflect.EnumType {
	return &file_MumbleTCP_proto_enumTypes[0]
}

func (x Reject_RejectType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Reject_RejectType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Reject_RejectType(num)
	return nil
}

// Deprecated: Use Reject_RejectType.Descriptor instead.
func (Reject_RejectType) EnumDescriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{4, 0}
}

type PermissionDenied_DenyType int32

const (
	// Operation denied for other reason, see reason field.
	PermissionDenied_Text PermissionDenied_DenyType = 0
	// Permissions were denied.
	PermissionDenied_Permission PermissionDenied_DenyType = 1
	// Cannot modify SuperUser.
	PermissionDenied_SuperUser PermissionDenied_DenyType = 2
	// Invalid channel name.
	PermissionDenied_ChannelName PermissionDenied_DenyType = 3
	// Text message too long.
	PermissionDenied_TextTooLong PermissionDenied_DenyType = 4
	// The flux capacitor was spelled wrong.
	PermissionDenied_H9K PermissionDenied_DenyType = 5
	// Operation not permitted in temporary channel.
	PermissionDenied_TemporaryChannel PermissionDenied_DenyType = 6
	// Operation requires certificate.
	PermissionDenied_MissingCertificate PermissionDenied_DenyType = 7
	// Invalid username.
	PermissionDenied_UserName PermissionDenied_DenyType = 8
	// Channel is full.
	PermissionDenied_ChannelFull PermissionDenied_DenyType = 9
	// Channels are nested too deeply.
	PermissionDenied_NestingLimit PermissionDenied_DenyType = 10
	// Maximum channel count reached.
	PermissionDenied_ChannelCountLimit PermissionDenied_DenyType = 11
	// Amount of listener objects for this channel has been reached
	PermissionDenied_ChannelListenerLimit PermissionDenied_DenyType = 12
	// Amount of listener proxies for the user has been reached
	PermissionDenied_UserListenerLimit PermissionDenied_DenyType = 13
)

// Enum value maps for PermissionDenied_DenyType.
var (
	PermissionDenied_DenyType_name = map[int32]string{
		0:  "Text",
		1:  "Permission",
		2:  "SuperUser",
		3:  "ChannelName",
		4:  "TextTooLong",
		5:  "H9K",
		6:  "TemporaryChannel",
		7:  "MissingCertificate",
		8:  "UserName",
		9:  "ChannelFull",
		10: "NestingLimit",
		11: "ChannelCountLimit",
		12: "ChannelListenerLimit",
		13: "UserListenerLimit",
	}
	PermissionDenied_DenyType_value = map[string]int32{
		"Text":                 0,
		"Permission":           1,
		"SuperUser":            2,
		"ChannelName":          3,
		"TextTooLong":          4,
		"H9K":                  5,
		"TemporaryChannel":     6,
		"MissingCertificate":   7,
		"UserName":             8,
		"ChannelFull":          9,
		"NestingLimit":         10,
		"ChannelCountLimit":    11,
		"ChannelListenerLimit": 12,
		"UserListenerLimit":    13,
	}
)

func (x PermissionDenied_DenyType) Enum() *PermissionDenied_DenyType {
	p := new(PermissionDenied_DenyType)
	*p = x
	return p
}

func (x PermissionDenied_DenyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PermissionDenied_DenyType) Descriptor() protoreflect.EnumDescriptor {
	return file_MumbleTCP_proto_enumTypes[1].Descriptor()
}

func (PermissionDenied_DenyType) Type() protoreflect.EnumType {
	return &file_MumbleTCP_proto_enumTypes[1]
}

func (x PermissionDenied_DenyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *PermissionDenied_DenyType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = PermissionDenied_DenyType(num)
	return nil
}

// Deprecated: Use PermissionDenied_DenyType.Descriptor instead.
func (PermissionDenied_DenyType) EnumDescriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{12, 0}
}

type ContextActionModify_Context int32

const (
	// Action is applicable to the server.
	ContextActionModify_Server ContextActionModify_Context = 1
	// Action can target a Channel.
	ContextActionModify_Channel ContextActionModify_Context = 2
	// Action can target a User.
	ContextActionModify_User ContextActionModify_Context = 4
)

// Enum value maps for ContextActionModify_Context.
var (
	ContextActionModify_Context_name = map[int32]string{
		1: "Server",
		2: "Channel",
		4: "User",
	}
	ContextActionModify_Context_value = map[string]int32{
		"Server":  1,
		"Channel": 2,
		"User":    4,
	}
)

func (x ContextActionModify_Context) Enum() *ContextActionModify_Context {
	p := new(ContextActionModify_Context)
	*p = x
	return p
}

func (x ContextActionModify_Context) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ContextActionModify_Context) Descriptor() protoreflect.EnumDescriptor {
	return file_MumbleTCP_proto_enumTypes[2].Descriptor()
}

func (ContextActionModify_Context) Type() protoreflect.EnumType {
	return &file_MumbleTCP_proto_enumTypes[2]
}

func (x ContextActionModify_Context) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ContextActionModify_Context) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ContextActionModify_Context(num)
	return nil
}

// Deprecated: Use ContextActionModify_Context.Descriptor instead.
func (ContextActionModify_Context) EnumDescriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{16, 0}
}

type ContextActionModify_Operation int32

const (
	ContextActionModify_Add    ContextActionModify_Operation = 0
	ContextActionModify_Remove ContextActionModify_Operation = 1
)

// Enum value maps for ContextActionModify_Operation.
var (
	ContextActionModify_Operation_name = map[int32]string{
		0: "Add",
		1: "Remove",
	}
	ContextActionModify_Operation_value = map[string]int32{
		"Add":    0,
		"Remove": 1,
	}
)

func (x ContextActionModify_Operation) Enum() *ContextActionModify_Operation {
	p := new(ContextActionModify_Operation)
	*p = x
	return p
}

func (x ContextActionModify_Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ContextActionModify_Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_MumbleTCP_proto_enumTypes[3].Descriptor()
}

func (ContextActionModify_Operation) Type() protoreflect.EnumType {
	return &file_MumbleTCP_proto_enumTypes[3]
}

func (x ContextActionModify_Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ContextActionModify_Operation) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ContextActionModify_Operation(num)
	return nil
}

// Deprecated: Use ContextActionModify_Operation.Descriptor instead.
func (ContextActionModify_Operation) EnumDescriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{16, 1}
}

type Version struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Legacy version number format.
	VersionV1 *uint32 `protobuf:"varint,1,opt,name=version_v1,json=versionV1" json:"version_v1,omitempty"`
	// New version number format.
	// Necessary since patch level may exceed 255. (See https://github.com/mumble-voip/mumble/issues/5827)
	VersionV2 *uint64 `protobuf:"varint,5,opt,name=version_v2,json=versionV2" json:"version_v2,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion     *string `protobuf:"bytes,4,opt,name=os_version,json=osVersion" json:"os_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Version) Reset() {
	*x = Version{}
	mi := &file_MumbleTCP_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Version) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Version) ProtoMessage() {}

func (x *Version) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Version.ProtoReflect.Descriptor instead.
func (*Version) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{0}
}

func (x *Version) GetVersionV1() uint32 {
	if x != nil && x.VersionV1 != nil {
		return *x.VersionV1
	}
	return 0
}

func (x *Version) GetVersionV2() uint64 {
	if x != nil && x.VersionV2 != nil {
		return *x.VersionV2
	}
	return 0
}

func (x *Version) GetRelease() string {
	if x != nil && x.Release != nil {
		return *x.Release
	}
	return ""
}

func (x *Version) GetOs() string {
	if x != nil && x.Os != nil {
		return *x.Os
	}
	return ""
}

func (x *Version) GetOsVersion() string {
	if x != nil && x.OsVersion != nil {
		return *x.OsVersion
	}
	return ""
}

// Not used. Not even for tunneling UDP through TCP.
type UDPTunnel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Not used.
	Packet        []byte `protobuf:"bytes,1,req,name=packet" json:"packet,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UDPTunnel) Reset() {
	*x = UDPTunnel{}
	mi := &file_MumbleTCP_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UDPTunnel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UDPTunnel) ProtoMessage() {}

func (x *UDPTunnel) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UDPTunnel.ProtoReflect.Descriptor instead.
func (*UDPTunnel) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{1}
}

func (x *UDPTunnel) GetPacket() []byte {
	if x != nil {
		return x.Packet
	}
	return nil
}

// Used by the client to send the authentication credentials to the server.
type Authenticate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UTF-8 encoded username.
	Username *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Server or user password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// Additional access tokens for server ACL groups.
	Tokens []string `protobuf:"bytes,3,rep,name=tokens" json:"tokens,omitempty"`
	// A list of CELT bitstream version constants supported by the client.
	CeltVersions []int32 `protobuf:"varint,4,rep,name=celt_versions,json=celtVersions" json:"celt_versions,omitempty"`
	Opus         *bool   `protobuf:"varint,5,opt,name=opus,def=0" json:"opus,omitempty"`
	// 0 = REGULAR, 1 = BOT
	ClientType    *int32 `protobuf:"varint,6,opt,name=client_type,json=clientType,def=0" json:"client_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for Authenticate fields.
const (
	Default_Authenticate_Opus       = bool(false)
	Default_Authenticate_ClientType = int32(0)
)

func (x *Authenticate) Reset() {
	*x = Authenticate{}
	mi := &file_MumbleTCP_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authenticate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authenticate) ProtoMessage() {}

func (x *Authenticate) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Authenticate.ProtoReflect.Descriptor instead.
func (*Authenticate) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{2}
}

func (x *Authenticate) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *Authenticate) GetPassword() string {
	if x != nil && x.Password != nil {
		return *x.Password
	}
	return ""
}

func (x *Authenticate) GetTokens() []string {
	if x != nil {
		return x.Tokens
	}
	return nil
}

func (x *Authenticate) GetCeltVersions() []int32 {
	if x != nil {
		return x.CeltVersions
	}
	return nil
}

func (x *Authenticate) GetOpus() bool {
	if x != nil && x.Opus != nil {
		return *x.Opus
	}
	return Default_Authenticate_Opus
}

func (x *Authenticate) GetClientType() int32 {
	if x != nil && x.ClientType != nil {
		return *x.ClientType
	}
	return Default_Authenticate_ClientType
}

// Sent by the client to notify the server that the client is still alive.
// Server must reply to the packet with the same timestamp and its own
// good/late/lost/resync numbers. None of the fields is strictly required.
type Ping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client timestamp. Server should not attempt to decode.
	Timestamp *uint64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,2,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,3,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,4,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync *uint32 `protobuf:"varint,5,opt,name=resync" json:"resync,omitempty"`
	// The total amount of UDP packets received.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets,json=udpPackets" json:"udp_packets,omitempty"`
	// The total amount of TCP packets received.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets,json=tcpPackets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg,json=udpPingAvg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var,json=udpPingVar" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg,json=tcpPingAvg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar    *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var,json=tcpPingVar" json:"tcp_ping_var,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ping) Reset() {
	*x = Ping{}
	mi := &file_MumbleTCP_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ping) ProtoMessage() {}

func (x *Ping) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ping.ProtoReflect.Descriptor instead.
func (*Ping) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{3}
}

func (x *Ping) GetTimestamp() uint64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *Ping) GetGood() uint32 {
	if x != nil && x.Good != nil {
		return *x.Good
	}
	return 0
}

func (x *Ping) GetLate() uint32 {
	if x != nil && x.Late != nil {
		return *x.Late
	}
	return 0
}

func (x *Ping) GetLost() uint32 {
	if x != nil && x.Lost != nil {
		return *x.Lost
	}
	return 0
}

func (x *Ping) GetResync() uint32 {
	if x != nil && x.Resync != nil {
		return *x.Resync
	}
	return 0
}

func (x *Ping) GetUdpPackets() uint32 {
	if x != nil && x.UdpPackets != nil {
		return *x.UdpPackets
	}
	return 0
}

func (x *Ping) GetTcpPackets() uint32 {
	if x != nil && x.TcpPackets != nil {
		return *x.TcpPackets
	}
	return 0
}

func (x *Ping) GetUdpPingAvg() float32 {
	if x != nil && x.UdpPingAvg != nil {
		return *x.UdpPingAvg
	}
	return 0
}

func (x *Ping) GetUdpPingVar() float32 {
	if x != nil && x.UdpPingVar != nil {
		return *x.UdpPingVar
	}
	return 0
}

func (x *Ping) GetTcpPingAvg() float32 {
	if x != nil && x.TcpPingAvg != nil {
		return *x.TcpPingAvg
	}
	return 0
}

func (x *Ping) GetTcpPingVar() float32 {
	if x != nil && x.TcpPingVar != nil {
		return *x.TcpPingVar
	}
	return 0
}

// Sent by the server when it rejects the user connection.
type Reject struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Rejection type.
	Type *Reject_RejectType `protobuf:"varint,1,opt,name=type,enum=MumbleProto.Reject_RejectType" json:"type,omitempty"`
	// Human readable rejection reason.
	Reason        *string `protobuf:"bytes,2,opt,name=reason" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Reject) Reset() {
	*x = Reject{}
	mi := &file_MumbleTCP_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Reject) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Reject) ProtoMessage() {}

func (x *Reject) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Reject.ProtoReflect.Descriptor instead.
func (*Reject) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{4}
}

func (x *Reject) GetType() Reject_RejectType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Reject_None
}

func (x *Reject) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

// ServerSync message is sent by the server when it has authenticated the user
// and finished synchronizing the server state.
type ServerSync struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The session of the current user.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// Maximum bandwidth that the user should use.
	MaxBandwidth *uint32 `protobuf:"varint,2,opt,name=max_bandwidth,json=maxBandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,3,opt,name=welcome_text,json=welcomeText" json:"welcome_text,omitempty"`
	// Current user permissions in the root channel.
	// Note: The permissions data type usually is uin32 (e.g. in PermissionQuery and PermissionDenied messages). Here
	// it is uint64 because of an oversight in the past. Nonetheless it should never exceed the uin32 range.
	// See also: https://github.com/mumble-voip/mumble/issues/5139
	Permissions   *uint64 `protobuf:"varint,4,opt,name=permissions" json:"permissions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerSync) Reset() {
	*x = ServerSync{}
	mi := &file_MumbleTCP_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerSync) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerSync) ProtoMessage() {}

func (x *ServerSync) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerSync.ProtoReflect.Descriptor instead.
func (*ServerSync) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{5}
}

func (x *ServerSync) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *ServerSync) GetMaxBandwidth() uint32 {
	if x != nil && x.MaxBandwidth != nil {
		return *x.MaxBandwidth
	}
	return 0
}

func (x *ServerSync) GetWelcomeText() string {
	if x != nil && x.WelcomeText != nil {
		return *x.WelcomeText
	}
	return ""
}

func (x *ServerSync) GetPermissions() uint64 {
	if x != nil && x.Permissions != nil {
		return *x.Permissions
	}
	return 0
}

// Sent by the client when it wants a channel removed. Sent by the server when
// a channel has been removed and clients should be notified.
type ChannelRemove struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChannelId     *uint32                `protobuf:"varint,1,req,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelRemove) Reset() {
	*x = ChannelRemove{}
	mi := &file_MumbleTCP_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelRemove) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelRemove) ProtoMessage() {}

func (x *ChannelRemove) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelRemove.ProtoReflect.Descriptor instead.
func (*ChannelRemove) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{6}
}

func (x *ChannelRemove) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

// Used to communicate channel properties between the client and the server.
// Sent by the server during the login process or when channel properties are
// updated. Client may use this message to update said channel properties.
type ChannelState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique ID for the channel within the server.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// channel_id of the parent channel.
	Parent *uint32 `protobuf:"varint,2,opt,name=parent" json:"parent,omitempty"`
	// UTF-8 encoded channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// A collection of channel id values of the linked channels. Absent during
	// the first channel listing.
	Links []uint32 `protobuf:"varint,4,rep,name=links" json:"links,omitempty"`
	// UTF-8 encoded channel description. Only if the description is less than
	// 128 bytes
	Description *string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A collection of channel_id values that should be added to links.
	LinksAdd []uint32 `protobuf:"varint,6,rep,name=links_add,json=linksAdd" json:"links_add,omitempty"`
	// A collection of channel_id values that should be removed from links.
	LinksRemove []uint32 `protobuf:"varint,7,rep,name=links_remove,json=linksRemove" json:"links_remove,omitempty"`
	// True if the channel is temporary.
	Temporary *bool `protobuf:"varint,8,opt,name=temporary,def=0" json:"temporary,omitempty"`
	// Position weight to tweak the channel position in the channel list.
	Position *int32 `protobuf:"varint,9,opt,name=position,def=0" json:"position,omitempty"`
	// SHA1 hash of the description if the description is 128 bytes or more.
	DescriptionHash []byte `protobuf:"bytes,10,opt,name=description_hash,json=descriptionHash" json:"description_hash,omitempty"`
	// Maximum number of users allowed in the channel. If this value is zero,
	// the maximum number of users allowed in the channel is given by the
	// server's "usersperchannel" setting.
	MaxUsers *uint32 `protobuf:"varint,11,opt,name=max_users,json=maxUsers" json:"max_users,omitempty"`
	// Whether this channel has enter restrictions (ACL denying ENTER) set
	IsEnterRestricted *bool `protobuf:"varint,12,opt,name=is_enter_restricted,json=isEnterRestricted" json:"is_enter_restricted,omitempty"`
	// Whether the receiver of this msg is considered to be able to enter this channel
	CanEnter      *bool `protobuf:"varint,13,opt,name=can_enter,json=canEnter" json:"can_enter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for ChannelState fields.
const (
	Default_ChannelState_Temporary = bool(false)
	Default_ChannelState_Position  = int32(0)
)

func (x *ChannelState) Reset() {
	*x = ChannelState{}
	mi := &file_MumbleTCP_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelState) ProtoMessage() {}

func (x *ChannelState) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelState.ProtoReflect.Descriptor instead.
func (*ChannelState) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{7}
}

func (x *ChannelState) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *ChannelState) GetParent() uint32 {
	if x != nil && x.Parent != nil {
		return *x.Parent
	}
	return 0
}

func (x *ChannelState) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ChannelState) GetLinks() []uint32 {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ChannelState) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

func (x *ChannelState) GetLinksAdd() []uint32 {
	if x != nil {
		return x.LinksAdd
	}
	return nil
}

func (x *ChannelState) GetLinksRemove() []uint32 {
	if x != nil {
		return x.LinksRemove
	}
	return nil
}

func (x *ChannelState) GetTemporary() bool {
	if x != nil && x.Temporary != nil {
		return *x.Temporary
	}
	return Default_ChannelState_Temporary
}

func (x *ChannelState) GetPosition() int32 {
	if x != nil && x.Position != nil {
		return *x.Position
	}
	return Default_ChannelState_Position
}

func (x *ChannelState) GetDescriptionHash() []byte {
	if x != nil {
		return x.DescriptionHash
	}
	return nil
}

func (x *ChannelState) GetMaxUsers() uint32 {
	if x != nil && x.MaxUsers != nil {
		return *x.MaxUsers
	}
	return 0
}

func (x *ChannelState) GetIsEnterRestricted() bool {
	if x != nil && x.IsEnterRestricted != nil {
		return *x.IsEnterRestricted
	}
	return false
}

func (x *ChannelState) GetCanEnter() bool {
	if x != nil && x.CanEnter != nil {
		return *x.CanEnter
	}
	return false
}

// Used to communicate user leaving or being kicked. May be sent by the client
// when it attempts to kick a user. Sent by the server when it informs the
// clients that a user is not present anymore.
type UserRemove struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The user who is being kicked, identified by their session, not present
	// when no one is being kicked.
	Session *uint32 `protobuf:"varint,1,req,name=session" json:"session,omitempty"`
	// The user who initiated the removal. Either the user who performs the kick
	// or the user who is currently leaving.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// Reason for the kick, stored as the ban reason if the user is banned.
	Reason *string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	// True if the kick should result in a ban.
	Ban           *bool `protobuf:"varint,4,opt,name=ban" json:"ban,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserRemove) Reset() {
	*x = UserRemove{}
	mi := &file_MumbleTCP_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserRemove) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserRemove) ProtoMessage() {}

func (x *UserRemove) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserRemove.ProtoReflect.Descriptor instead.
func (*UserRemove) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{8}
}

func (x *UserRemove) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *UserRemove) GetActor() uint32 {
	if x != nil && x.Actor != nil {
		return *x.Actor
	}
	return 0
}

func (x *UserRemove) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *UserRemove) GetBan() bool {
	if x != nil && x.Ban != nil {
		return *x.Ban
	}
	return false
}

// Sent by the server when it communicates new and changed users to client.
// First seen during login procedure. May be sent by the client when it wishes
// to alter its state.
type UserState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique user session ID of the user whose state this is, may change on
	// reconnect.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The session of the user who is updating this user.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// User name, UTF-8 encoded.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Registered user ID if the user is registered.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Channel on which the user is.
	ChannelId *uint32 `protobuf:"varint,5,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// True if the user is muted by admin.
	Mute *bool `protobuf:"varint,6,opt,name=mute" json:"mute,omitempty"`
	// True if the user is deafened by admin.
	Deaf *bool `protobuf:"varint,7,opt,name=deaf" json:"deaf,omitempty"`
	// True if the user has been suppressed from talking by a reason other than
	// being muted.
	Suppress *bool `protobuf:"varint,8,opt,name=suppress" json:"suppress,omitempty"`
	// True if the user has muted self.
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute,json=selfMute" json:"self_mute,omitempty"`
	// True if the user has deafened self.
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf,json=selfDeaf" json:"self_deaf,omitempty"`
	// User image if it is less than 128 bytes.
	Texture []byte `protobuf:"bytes,11,opt,name=texture" json:"texture,omitempty"`
	// The positional audio plugin identifier.
	// Positional audio information is only sent to users who share
	// identical plugin contexts.
	//
	// This value is not transmitted to clients.
	PluginContext []byte `protobuf:"bytes,12,opt,name=plugin_context,json=pluginContext" json:"plugin_context,omitempty"`
	// The user's plugin-specific identity.
	// This value is not transmitted to clients.
	PluginIdentity *string `protobuf:"bytes,13,opt,name=plugin_identity,json=pluginIdentity" json:"plugin_identity,omitempty"`
	// User comment if it is less than 128 bytes.
	Comment *string `protobuf:"bytes,14,opt,name=comment" json:"comment,omitempty"`
	// The hash of the user certificate.
	Hash *string `protobuf:"bytes,15,opt,name=hash" json:"hash,omitempty"`
	// SHA1 hash of the user comment if it 128 bytes or more.
	CommentHash []byte `protobuf:"bytes,16,opt,name=comment_hash,json=commentHash" json:"comment_hash,omitempty"`
	// SHA1 hash of the user picture if it 128 bytes or more.
	TextureHash []byte `protobuf:"bytes,17,opt,name=texture_hash,json=textureHash" json:"texture_hash,omitempty"`
	// True if the user is a priority speaker.
	PrioritySpeaker *bool `protobuf:"varint,18,opt,name=priority_speaker,json=prioritySpeaker" json:"priority_speaker,omitempty"`
	// True if the user is currently recording.
	Recording *bool `protobuf:"varint,19,opt,name=recording" json:"recording,omitempty"`
	// A list of temporary access tokens to be respected when processing this request.
	TemporaryAccessTokens []string `protobuf:"bytes,20,rep,name=temporary_access_tokens,json=temporaryAccessTokens" json:"temporary_access_tokens,omitempty"`
	// A list of channels the user wants to start listening to.
	ListeningChannelAdd []uint32 `protobuf:"varint,21,rep,name=listening_channel_add,json=listeningChannelAdd" json:"listening_channel_add,omitempty"`
	// a list of channels the user does no longer want to listen to.
	ListeningChannelRemove []uint32 `protobuf:"varint,22,rep,name=listening_channel_remove,json=listeningChannelRemove" json:"listening_channel_remove,omitempty"`
	// A list of volume adjustments the user has applied to listeners
	ListeningVolumeAdjustment []*UserState_VolumeAdjustment `protobuf:"bytes,23,rep,name=listening_volume_adjustment,json=listeningVolumeAdjustment" json:"listening_volume_adjustment,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *UserState) Reset() {
	*x = UserState{}
	mi := &file_MumbleTCP_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserState) ProtoMessage() {}

func (x *UserState) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserState.ProtoReflect.Descriptor instead.
func (*UserState) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{9}
}

func (x *UserState) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *UserState) GetActor() uint32 {
	if x != nil && x.Actor != nil {
		return *x.Actor
	}
	return 0
}

func (x *UserState) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *UserState) GetUserId() uint32 {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return 0
}

func (x *UserState) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *UserState) GetMute() bool {
	if x != nil && x.Mute != nil {
		return *x.Mute
	}
	return false
}

func (x *UserState) GetDeaf() bool {
	if x != nil && x.Deaf != nil {
		return *x.Deaf
	}
	return false
}

func (x *UserState) GetSuppress() bool {
	if x != nil && x.Suppress != nil {
		return *x.Suppress
	}
	return false
}

func (x *UserState) GetSelfMute() bool {
	if x != nil && x.SelfMute != nil {
		return *x.SelfMute
	}
	return false
}

func (x *UserState) GetSelfDeaf() bool {
	if x != nil && x.SelfDeaf != nil {
		return *x.SelfDeaf
	}
	return false
}

func (x *UserState) GetTexture() []byte {
	if x != nil {
		return x.Texture
	}
	return nil
}

func (x *UserState) GetPluginContext() []byte {
	if x != nil {
		return x.PluginContext
	}
	return nil
}

func (x *UserState) GetPluginIdentity() string {
	if x != nil && x.PluginIdentity != nil {
		return *x.PluginIdentity
	}
	return ""
}

func (x *UserState) GetComment() string {
	if x != nil && x.Comment != nil {
		return *x.Comment
	}
	return ""
}

func (x *UserState) GetHash() string {
	if x != nil && x.Hash != nil {
		return *x.Hash
	}
	return ""
}

func (x *UserState) GetCommentHash() []byte {
	if x != nil {
		return x.CommentHash
	}
	return nil
}

func (x *UserState) GetTextureHash() []byte {
	if x != nil {
		return x.TextureHash
	}
	return nil
}

func (x *UserState) GetPrioritySpeaker() bool {
	if x != nil && x.PrioritySpeaker != nil {
		return *x.PrioritySpeaker
	}
	return false
}

func (x *UserState) GetRecording() bool {
	if x != nil && x.Recording != nil {
		return *x.Recording
	}
	return false
}

func (x *UserState) GetTemporaryAccessTokens() []string {
	if x != nil {
		return x.TemporaryAccessTokens
	}
	return nil
}

func (x *UserState) GetListeningChannelAdd() []uint32 {
	if x != nil {
		return x.ListeningChannelAdd
	}
	return nil
}

func (x *UserState) GetListeningChannelRemove() []uint32 {
	if x != nil {
		return x.ListeningChannelRemove
	}
	return nil
}

func (x *UserState) GetListeningVolumeAdjustment() []*UserState_VolumeAdjustment {
	if x != nil {
		return x.ListeningVolumeAdjustment
	}
	return nil
}

// Relays information on the bans. The client may send the BanList message to
// either modify the list of bans or query them from the server. The server
// sends this list only after a client queries for it.
type BanList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of ban entries currently in place.
	Bans []*BanList_BanEntry `protobuf:"bytes,1,rep,name=bans" json:"bans,omitempty"`
	// True if the server should return the list, false if it should replace old
	// ban list with the one provided.
	Query         *bool `protobuf:"varint,2,opt,name=query,def=0" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for BanList fields.
const (
	Default_BanList_Query = bool(false)
)

func (x *BanList) Reset() {
	*x = BanList{}
	mi := &file_MumbleTCP_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BanList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BanList) ProtoMessage() {}

func (x *BanList) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BanList.ProtoReflect.Descriptor instead.
func (*BanList) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{10}
}

func (x *BanList) GetBans() []*BanList_BanEntry {
	if x != nil {
		return x.Bans
	}
	return nil
}

func (x *BanList) GetQuery() bool {
	if x != nil && x.Query != nil {
		return *x.Query
	}
	return Default_BanList_Query
}

// Used to send and broadcast text messages.
type TextMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The message sender, identified by its session.
	Actor *uint32 `protobuf:"varint,1,opt,name=actor" json:"actor,omitempty"`
	// Target users for the message, identified by their session.
	Session []uint32 `protobuf:"varint,2,rep,name=session" json:"session,omitempty"`
	// The channels to which the message is sent, identified by their
	// channel_ids.
	ChannelId []uint32 `protobuf:"varint,3,rep,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The root channels when sending message recursively to several channels,
	// identified by their channel_ids.
	TreeId []uint32 `protobuf:"varint,4,rep,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// The UTF-8 encoded message. May be HTML if the server allows.
	Message       *string `protobuf:"bytes,5,req,name=message" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TextMessage) Reset() {
	*x = TextMessage{}
	mi := &file_MumbleTCP_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextMessage) ProtoMessage() {}

func (x *TextMessage) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextMessage.ProtoReflect.Descriptor instead.
func (*TextMessage) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{11}
}

func (x *TextMessage) GetActor() uint32 {
	if x != nil && x.Actor != nil {
		return *x.Actor
	}
	return 0
}

func (x *TextMessage) GetSession() []uint32 {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *TextMessage) GetChannelId() []uint32 {
	if x != nil {
		return x.ChannelId
	}
	return nil
}

func (x *TextMessage) GetTreeId() []uint32 {
	if x != nil {
		return x.TreeId
	}
	return nil
}

func (x *TextMessage) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

type PermissionDenied struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The denied permission when type is Permission.
	Permission *uint32 `protobuf:"varint,1,opt,name=permission" json:"permission,omitempty"`
	// channel_id for the channel where the permission was denied when type is
	// Permission.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The user who was denied permissions, identified by session.
	Session *uint32 `protobuf:"varint,3,opt,name=session" json:"session,omitempty"`
	// Textual reason for the denial.
	Reason *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	// Type of the denial.
	Type *PermissionDenied_DenyType `protobuf:"varint,5,opt,name=type,enum=MumbleProto.PermissionDenied_DenyType" json:"type,omitempty"`
	// The name that is invalid when type is UserName.
	Name          *string `protobuf:"bytes,6,opt,name=name" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionDenied) Reset() {
	*x = PermissionDenied{}
	mi := &file_MumbleTCP_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionDenied) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionDenied) ProtoMessage() {}

func (x *PermissionDenied) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionDenied.ProtoReflect.Descriptor instead.
func (*PermissionDenied) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{12}
}

func (x *PermissionDenied) GetPermission() uint32 {
	if x != nil && x.Permission != nil {
		return *x.Permission
	}
	return 0
}

func (x *PermissionDenied) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *PermissionDenied) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *PermissionDenied) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *PermissionDenied) GetType() PermissionDenied_DenyType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return PermissionDenied_Text
}

func (x *PermissionDenied) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

type ACL struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Channel ID of the channel this message affects.
	ChannelId *uint32 `protobuf:"varint,1,req,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// True if the channel inherits its parent's ACLs.
	InheritAcls *bool `protobuf:"varint,2,opt,name=inherit_acls,json=inheritAcls,def=1" json:"inherit_acls,omitempty"`
	// User group specifications.
	Groups []*ACL_ChanGroup `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	// ACL specifications.
	Acls []*ACL_ChanACL `protobuf:"bytes,4,rep,name=acls" json:"acls,omitempty"`
	// True if the message is a query for ACLs instead of setting them.
	Query         *bool `protobuf:"varint,5,opt,name=query,def=0" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for ACL fields.
const (
	Default_ACL_InheritAcls = bool(true)
	Default_ACL_Query       = bool(false)
)

func (x *ACL) Reset() {
	*x = ACL{}
	mi := &file_MumbleTCP_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACL) ProtoMessage() {}

func (x *ACL) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACL.ProtoReflect.Descriptor instead.
func (*ACL) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{13}
}

func (x *ACL) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *ACL) GetInheritAcls() bool {
	if x != nil && x.InheritAcls != nil {
		return *x.InheritAcls
	}
	return Default_ACL_InheritAcls
}

func (x *ACL) GetGroups() []*ACL_ChanGroup {
	if x != nil {
		return x.Groups
	}
	return nil
}

func (x *ACL) GetAcls() []*ACL_ChanACL {
	if x != nil {
		return x.Acls
	}
	return nil
}

func (x *ACL) GetQuery() bool {
	if x != nil && x.Query != nil {
		return *x.Query
	}
	return Default_ACL_Query
}

// Client may use this message to refresh its registered user information. The
// client should fill the IDs or Names of the users it wants to refresh. The
// server fills the missing parts and sends the message back.
type QueryUsers struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// user_ids.
	Ids []uint32 `protobuf:"varint,1,rep,name=ids" json:"ids,omitempty"`
	// User names in the same order as ids.
	Names         []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryUsers) Reset() {
	*x = QueryUsers{}
	mi := &file_MumbleTCP_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUsers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUsers) ProtoMessage() {}

func (x *QueryUsers) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUsers.ProtoReflect.Descriptor instead.
func (*QueryUsers) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{14}
}

func (x *QueryUsers) GetIds() []uint32 {
	if x != nil {
		return x.Ids
	}
	return nil
}

func (x *QueryUsers) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

// Used to initialize and resync the UDP encryption. Either side may request a
// resync by sending the message without any values filled. The resync is
// performed by sending the message with only the client or server nonce
// filled.
type CryptSetup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Encryption key.
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Client nonce.
	ClientNonce []byte `protobuf:"bytes,2,opt,name=client_nonce,json=clientNonce" json:"client_nonce,omitempty"`
	// Server nonce.
	ServerNonce   []byte `protobuf:"bytes,3,opt,name=server_nonce,json=serverNonce" json:"server_nonce,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CryptSetup) Reset() {
	*x = CryptSetup{}
	mi := &file_MumbleTCP_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CryptSetup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CryptSetup) ProtoMessage() {}

func (x *CryptSetup) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CryptSetup.ProtoReflect.Descriptor instead.
func (*CryptSetup) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{15}
}

func (x *CryptSetup) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CryptSetup) GetClientNonce() []byte {
	if x != nil {
		return x.ClientNonce
	}
	return nil
}

func (x *CryptSetup) GetServerNonce() []byte {
	if x != nil {
		return x.ServerNonce
	}
	return nil
}

// Used to add or remove custom context menu item on client-side.
type ContextActionModify struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The action identifier. Used later to initiate an action.
	Action *string `protobuf:"bytes,1,req,name=action" json:"action,omitempty"`
	// The display name of the action.
	Text *string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// Context bit flags defining where the action should be displayed.
	// Flags can be OR-ed to combine different types.
	Context *uint32 `protobuf:"varint,3,opt,name=context" json:"context,omitempty"`
	// Choose either to add or to remove the context action.
	// Note: This field only exists after Mumble 1.2.4-beta1 release.
	//
	//	The message will be recognized as Add regardless of this field
	//	before said release.
	Operation     *ContextActionModify_Operation `protobuf:"varint,4,opt,name=operation,enum=MumbleProto.ContextActionModify_Operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContextActionModify) Reset() {
	*x = ContextActionModify{}
	mi := &file_MumbleTCP_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContextActionModify) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContextActionModify) ProtoMessage() {}

func (x *ContextActionModify) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContextActionModify.ProtoReflect.Descriptor instead.
func (*ContextActionModify) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{16}
}

func (x *ContextActionModify) GetAction() string {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return ""
}

func (x *ContextActionModify) GetText() string {
	if x != nil && x.Text != nil {
		return *x.Text
	}
	return ""
}

func (x *ContextActionModify) GetContext() uint32 {
	if x != nil && x.Context != nil {
		return *x.Context
	}
	return 0
}

func (x *ContextActionModify) GetOperation() ContextActionModify_Operation {
	if x != nil && x.Operation != nil {
		return *x.Operation
	}
	return ContextActionModify_Add
}

// Sent by the client when it wants to initiate a Context action.
type ContextAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The target User for the action, identified by session.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The target Channel for the action, identified by channel_id.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The action that should be executed.
	Action        *string `protobuf:"bytes,3,req,name=action" json:"action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContextAction) Reset() {
	*x = ContextAction{}
	mi := &file_MumbleTCP_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContextAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContextAction) ProtoMessage() {}

func (x *ContextAction) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContextAction.ProtoReflect.Descriptor instead.
func (*ContextAction) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{17}
}

func (x *ContextAction) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *ContextAction) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *ContextAction) GetAction() string {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return ""
}

// Lists the registered users.
type UserList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of registered users.
	Users         []*UserList_User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserList) Reset() {
	*x = UserList{}
	mi := &file_MumbleTCP_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserList) ProtoMessage() {}

func (x *UserList) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserList.ProtoReflect.Descriptor instead.
func (*UserList) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{18}
}

func (x *UserList) GetUsers() []*UserList_User {
	if x != nil {
		return x.Users
	}
	return nil
}

// Sent by the client when it wants to register or clear whisper targets.
//
// Note: The first available target ID is 1 as 0 is reserved for normal
// talking. Maximum target ID is 30.
type VoiceTarget struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Voice target ID.
	Id *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The receivers that this voice target includes.
	Targets       []*VoiceTarget_Target `protobuf:"bytes,2,rep,name=targets" json:"targets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VoiceTarget) Reset() {
	*x = VoiceTarget{}
	mi := &file_MumbleTCP_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VoiceTarget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VoiceTarget) ProtoMessage() {}

func (x *VoiceTarget) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VoiceTarget.ProtoReflect.Descriptor instead.
func (*VoiceTarget) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{19}
}

func (x *VoiceTarget) GetId() uint32 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

func (x *VoiceTarget) GetTargets() []*VoiceTarget_Target {
	if x != nil {
		return x.Targets
	}
	return nil
}

// Sent by the client when it wants permissions for a certain channel. Sent by
// the server when it replies to the query or wants the user to resync all
// channel permissions.
type PermissionQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// channel_id of the channel for which the permissions are queried.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// Channel permissions.
	Permissions *uint32 `protobuf:"varint,2,opt,name=permissions" json:"permissions,omitempty"`
	// True if the client should drop its current permission information for all
	// channels.
	Flush         *bool `protobuf:"varint,3,opt,name=flush,def=0" json:"flush,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for PermissionQuery fields.
const (
	Default_PermissionQuery_Flush = bool(false)
)

func (x *PermissionQuery) Reset() {
	*x = PermissionQuery{}
	mi := &file_MumbleTCP_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionQuery) ProtoMessage() {}

func (x *PermissionQuery) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionQuery.ProtoReflect.Descriptor instead.
func (*PermissionQuery) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{20}
}

func (x *PermissionQuery) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *PermissionQuery) GetPermissions() uint32 {
	if x != nil && x.Permissions != nil {
		return *x.Permissions
	}
	return 0
}

func (x *PermissionQuery) GetFlush() bool {
	if x != nil && x.Flush != nil {
		return *x.Flush
	}
	return Default_PermissionQuery_Flush
}

// Sent by the server to notify the users of the version of the CELT codec they
// should use. This may change during the connection when new users join.
type CodecVersion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The version of the CELT Alpha codec.
	Alpha *int32 `protobuf:"varint,1,req,name=alpha" json:"alpha,omitempty"`
	// The version of the CELT Beta codec.
	Beta *int32 `protobuf:"varint,2,req,name=beta" json:"beta,omitempty"`
	// True if the user should prefer Alpha over Beta.
	PreferAlpha   *bool `protobuf:"varint,3,req,name=prefer_alpha,json=preferAlpha,def=1" json:"prefer_alpha,omitempty"`
	Opus          *bool `protobuf:"varint,4,opt,name=opus,def=0" json:"opus,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for CodecVersion fields.
const (
	Default_CodecVersion_PreferAlpha = bool(true)
	Default_CodecVersion_Opus        = bool(false)
)

func (x *CodecVersion) Reset() {
	*x = CodecVersion{}
	mi := &file_MumbleTCP_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CodecVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CodecVersion) ProtoMessage() {}

func (x *CodecVersion) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CodecVersion.ProtoReflect.Descriptor instead.
func (*CodecVersion) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{21}
}

func (x *CodecVersion) GetAlpha() int32 {
	if x != nil && x.Alpha != nil {
		return *x.Alpha
	}
	return 0
}

func (x *CodecVersion) GetBeta() int32 {
	if x != nil && x.Beta != nil {
		return *x.Beta
	}
	return 0
}

func (x *CodecVersion) GetPreferAlpha() bool {
	if x != nil && x.PreferAlpha != nil {
		return *x.PreferAlpha
	}
	return Default_CodecVersion_PreferAlpha
}

func (x *CodecVersion) GetOpus() bool {
	if x != nil && x.Opus != nil {
		return *x.Opus
	}
	return Default_CodecVersion_Opus
}

// Used to communicate user stats between the server and clients.
type UserStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// User whose stats these are.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// True if the message contains only mutable stats (packets, ping).
	StatsOnly *bool `protobuf:"varint,2,opt,name=stats_only,json=statsOnly,def=0" json:"stats_only,omitempty"`
	// Full user certificate chain of the user certificate in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// Packet statistics for packets received from the client.
	FromClient *UserStats_Stats `protobuf:"bytes,4,opt,name=from_client,json=fromClient" json:"from_client,omitempty"`
	// Packet statistics for packets sent by the server.
	FromServer *UserStats_Stats `protobuf:"bytes,5,opt,name=from_server,json=fromServer" json:"from_server,omitempty"`
	// Amount of UDP packets sent.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets,json=udpPackets" json:"udp_packets,omitempty"`
	// Amount of TCP packets sent.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets,json=tcpPackets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg,json=udpPingAvg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var,json=udpPingVar" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg,json=tcpPingAvg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var,json=tcpPingVar" json:"tcp_ping_var,omitempty"`
	// Client version.
	Version *Version `protobuf:"bytes,12,opt,name=version" json:"version,omitempty"`
	// A list of CELT bitstream version constants supported by the client of this
	// user.
	CeltVersions []int32 `protobuf:"varint,13,rep,name=celt_versions,json=celtVersions" json:"celt_versions,omitempty"`
	// Client IP address.
	Address []byte `protobuf:"bytes,14,opt,name=address" json:"address,omitempty"`
	// Bandwidth used by this client.
	Bandwidth *uint32 `protobuf:"varint,15,opt,name=bandwidth" json:"bandwidth,omitempty"`
	// Connection duration.
	Onlinesecs *uint32 `protobuf:"varint,16,opt,name=onlinesecs" json:"onlinesecs,omitempty"`
	// Duration since last activity.
	Idlesecs *uint32 `protobuf:"varint,17,opt,name=idlesecs" json:"idlesecs,omitempty"`
	// True if the user has a strong certificate.
	StrongCertificate *bool `protobuf:"varint,18,opt,name=strong_certificate,json=strongCertificate,def=0" json:"strong_certificate,omitempty"`
	Opus              *bool `protobuf:"varint,19,opt,name=opus,def=0" json:"opus,omitempty"`
	// Rolling packet statistics
	RollingStats  *UserStats_RollingStats `protobuf:"bytes,20,opt,name=rolling_stats,json=rollingStats" json:"rolling_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for UserStats fields.
const (
	Default_UserStats_StatsOnly         = bool(false)
	Default_UserStats_StrongCertificate = bool(false)
	Default_UserStats_Opus              = bool(false)
)

func (x *UserStats) Reset() {
	*x = UserStats{}
	mi := &file_MumbleTCP_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStats) ProtoMessage() {}

func (x *UserStats) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStats.ProtoReflect.Descriptor instead.
func (*UserStats) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{22}
}

func (x *UserStats) GetSession() uint32 {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return 0
}

func (x *UserStats) GetStatsOnly() bool {
	if x != nil && x.StatsOnly != nil {
		return *x.StatsOnly
	}
	return Default_UserStats_StatsOnly
}

func (x *UserStats) GetCertificates() [][]byte {
	if x != nil {
		return x.Certificates
	}
	return nil
}

func (x *UserStats) GetFromClient() *UserStats_Stats {
	if x != nil {
		return x.FromClient
	}
	return nil
}

func (x *UserStats) GetFromServer() *UserStats_Stats {
	if x != nil {
		return x.FromServer
	}
	return nil
}

func (x *UserStats) GetUdpPackets() uint32 {
	if x != nil && x.UdpPackets != nil {
		return *x.UdpPackets
	}
	return 0
}

func (x *UserStats) GetTcpPackets() uint32 {
	if x != nil && x.TcpPackets != nil {
		return *x.TcpPackets
	}
	return 0
}

func (x *UserStats) GetUdpPingAvg() float32 {
	if x != nil && x.UdpPingAvg != nil {
		return *x.UdpPingAvg
	}
	return 0
}

func (x *UserStats) GetUdpPingVar() float32 {
	if x != nil && x.UdpPingVar != nil {
		return *x.UdpPingVar
	}
	return 0
}

func (x *UserStats) GetTcpPingAvg() float32 {
	if x != nil && x.TcpPingAvg != nil {
		return *x.TcpPingAvg
	}
	return 0
}

func (x *UserStats) GetTcpPingVar() float32 {
	if x != nil && x.TcpPingVar != nil {
		return *x.TcpPingVar
	}
	return 0
}

func (x *UserStats) GetVersion() *Version {
	if x != nil {
		return x.Version
	}
	return nil
}

func (x *UserStats) GetCeltVersions() []int32 {
	if x != nil {
		return x.CeltVersions
	}
	return nil
}

func (x *UserStats) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *UserStats) GetBandwidth() uint32 {
	if x != nil && x.Bandwidth != nil {
		return *x.Bandwidth
	}
	return 0
}

func (x *UserStats) GetOnlinesecs() uint32 {
	if x != nil && x.Onlinesecs != nil {
		return *x.Onlinesecs
	}
	return 0
}

func (x *UserStats) GetIdlesecs() uint32 {
	if x != nil && x.Idlesecs != nil {
		return *x.Idlesecs
	}
	return 0
}

func (x *UserStats) GetStrongCertificate() bool {
	if x != nil && x.StrongCertificate != nil {
		return *x.StrongCertificate
	}
	return Default_UserStats_StrongCertificate
}

func (x *UserStats) GetOpus() bool {
	if x != nil && x.Opus != nil {
		return *x.Opus
	}
	return Default_UserStats_Opus
}

func (x *UserStats) GetRollingStats() *UserStats_RollingStats {
	if x != nil {
		return x.RollingStats
	}
	return nil
}

// Used by the client to request binary data from the server. By default large
// comments or textures are not sent within standard messages but instead the
// hash is. If the client does not recognize the hash it may request the
// resource when it needs it. The client does so by sending a RequestBlob
// message with the correct fields filled with the user sessions or channel_ids
// it wants to receive. The server replies to this by sending a new
// UserState/ChannelState message with the resources filled even if they would
// normally be transmitted as hashes.
type RequestBlob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// sessions of the requested UserState textures.
	SessionTexture []uint32 `protobuf:"varint,1,rep,name=session_texture,json=sessionTexture" json:"session_texture,omitempty"`
	// sessions of the requested UserState comments.
	SessionComment []uint32 `protobuf:"varint,2,rep,name=session_comment,json=sessionComment" json:"session_comment,omitempty"`
	// channel_ids of the requested ChannelState descriptions.
	ChannelDescription []uint32 `protobuf:"varint,3,rep,name=channel_description,json=channelDescription" json:"channel_description,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *RequestBlob) Reset() {
	*x = RequestBlob{}
	mi := &file_MumbleTCP_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestBlob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestBlob) ProtoMessage() {}

func (x *RequestBlob) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestBlob.ProtoReflect.Descriptor instead.
func (*RequestBlob) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{23}
}

func (x *RequestBlob) GetSessionTexture() []uint32 {
	if x != nil {
		return x.SessionTexture
	}
	return nil
}

func (x *RequestBlob) GetSessionComment() []uint32 {
	if x != nil {
		return x.SessionComment
	}
	return nil
}

func (x *RequestBlob) GetChannelDescription() []uint32 {
	if x != nil {
		return x.ChannelDescription
	}
	return nil
}

// Sent by the server when it informs the clients on server configuration
// details.
type ServerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum bandwidth the clients should use.
	MaxBandwidth *uint32 `protobuf:"varint,1,opt,name=max_bandwidth,json=maxBandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,2,opt,name=welcome_text,json=welcomeText" json:"welcome_text,omitempty"`
	// True if the server allows HTML.
	AllowHtml *bool `protobuf:"varint,3,opt,name=allow_html,json=allowHtml" json:"allow_html,omitempty"`
	// Maximum text message length.
	MessageLength *uint32 `protobuf:"varint,4,opt,name=message_length,json=messageLength" json:"message_length,omitempty"`
	// Maximum image message length.
	ImageMessageLength *uint32 `protobuf:"varint,5,opt,name=image_message_length,json=imageMessageLength" json:"image_message_length,omitempty"`
	// The maximum number of users allowed on the server.
	MaxUsers *uint32 `protobuf:"varint,6,opt,name=max_users,json=maxUsers" json:"max_users,omitempty"`
	// Whether using Mumble's recording feature is allowed on the server
	RecordingAllowed *bool `protobuf:"varint,7,opt,name=recording_allowed,json=recordingAllowed" json:"recording_allowed,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ServerConfig) Reset() {
	*x = ServerConfig{}
	mi := &file_MumbleTCP_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerConfig) ProtoMessage() {}

func (x *ServerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerConfig.ProtoReflect.Descriptor instead.
func (*ServerConfig) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{24}
}

func (x *ServerConfig) GetMaxBandwidth() uint32 {
	if x != nil && x.MaxBandwidth != nil {
		return *x.MaxBandwidth
	}
	return 0
}

func (x *ServerConfig) GetWelcomeText() string {
	if x != nil && x.WelcomeText != nil {
		return *x.WelcomeText
	}
	return ""
}

func (x *ServerConfig) GetAllowHtml() bool {
	if x != nil && x.AllowHtml != nil {
		return *x.AllowHtml
	}
	return false
}

func (x *ServerConfig) GetMessageLength() uint32 {
	if x != nil && x.MessageLength != nil {
		return *x.MessageLength
	}
	return 0
}

func (x *ServerConfig) GetImageMessageLength() uint32 {
	if x != nil && x.ImageMessageLength != nil {
		return *x.ImageMessageLength
	}
	return 0
}

func (x *ServerConfig) GetMaxUsers() uint32 {
	if x != nil && x.MaxUsers != nil {
		return *x.MaxUsers
	}
	return 0
}

func (x *ServerConfig) GetRecordingAllowed() bool {
	if x != nil && x.RecordingAllowed != nil {
		return *x.RecordingAllowed
	}
	return false
}

// Sent by the server to inform the clients of suggested client configuration
// specified by the server administrator.
type SuggestConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Suggested client version in the legacy format.
	VersionV1 *uint32 `protobuf:"varint,1,opt,name=version_v1,json=versionV1" json:"version_v1,omitempty"`
	// Suggested client version in the new format.
	// Necessary since patch level may exceed 255. (See https://github.com/mumble-voip/mumble/issues/5827)
	VersionV2 *uint64 `protobuf:"varint,4,opt,name=version_v2,json=versionV2" json:"version_v2,omitempty"`
	// True if the administrator suggests positional audio to be used on this
	// server.
	Positional *bool `protobuf:"varint,2,opt,name=positional" json:"positional,omitempty"`
	// True if the administrator suggests push to talk to be used on this server.
	PushToTalk    *bool `protobuf:"varint,3,opt,name=push_to_talk,json=pushToTalk" json:"push_to_talk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SuggestConfig) Reset() {
	*x = SuggestConfig{}
	mi := &file_MumbleTCP_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SuggestConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SuggestConfig) ProtoMessage() {}

func (x *SuggestConfig) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SuggestConfig.ProtoReflect.Descriptor instead.
func (*SuggestConfig) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{25}
}

func (x *SuggestConfig) GetVersionV1() uint32 {
	if x != nil && x.VersionV1 != nil {
		return *x.VersionV1
	}
	return 0
}

func (x *SuggestConfig) GetVersionV2() uint64 {
	if x != nil && x.VersionV2 != nil {
		return *x.VersionV2
	}
	return 0
}

func (x *SuggestConfig) GetPositional() bool {
	if x != nil && x.Positional != nil {
		return *x.Positional
	}
	return false
}

func (x *SuggestConfig) GetPushToTalk() bool {
	if x != nil && x.PushToTalk != nil {
		return *x.PushToTalk
	}
	return false
}

// Used to send plugin messages between clients
type PluginDataTransmission struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The session ID of the client this message was sent from
	SenderSession *uint32 `protobuf:"varint,1,opt,name=senderSession" json:"senderSession,omitempty"`
	// The session IDs of the clients that should receive this message
	ReceiverSessions []uint32 `protobuf:"varint,2,rep,packed,name=receiverSessions" json:"receiverSessions,omitempty"`
	// The data that is sent
	Data []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// The ID of the sent data. This will be used by plugins to check whether they will
	// process it or not
	DataID        *string `protobuf:"bytes,4,opt,name=dataID" json:"dataID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginDataTransmission) Reset() {
	*x = PluginDataTransmission{}
	mi := &file_MumbleTCP_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginDataTransmission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginDataTransmission) ProtoMessage() {}

func (x *PluginDataTransmission) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginDataTransmission.ProtoReflect.Descriptor instead.
func (*PluginDataTransmission) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{26}
}

func (x *PluginDataTransmission) GetSenderSession() uint32 {
	if x != nil && x.SenderSession != nil {
		return *x.SenderSession
	}
	return 0
}

func (x *PluginDataTransmission) GetReceiverSessions() []uint32 {
	if x != nil {
		return x.ReceiverSessions
	}
	return nil
}

func (x *PluginDataTransmission) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *PluginDataTransmission) GetDataID() string {
	if x != nil && x.DataID != nil {
		return *x.DataID
	}
	return ""
}

type UserState_VolumeAdjustment struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ListeningChannel *uint32                `protobuf:"varint,1,opt,name=listening_channel,json=listeningChannel" json:"listening_channel,omitempty"`
	VolumeAdjustment *float32               `protobuf:"fixed32,2,opt,name=volume_adjustment,json=volumeAdjustment" json:"volume_adjustment,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UserState_VolumeAdjustment) Reset() {
	*x = UserState_VolumeAdjustment{}
	mi := &file_MumbleTCP_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserState_VolumeAdjustment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserState_VolumeAdjustment) ProtoMessage() {}

func (x *UserState_VolumeAdjustment) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserState_VolumeAdjustment.ProtoReflect.Descriptor instead.
func (*UserState_VolumeAdjustment) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{9, 0}
}

func (x *UserState_VolumeAdjustment) GetListeningChannel() uint32 {
	if x != nil && x.ListeningChannel != nil {
		return *x.ListeningChannel
	}
	return 0
}

func (x *UserState_VolumeAdjustment) GetVolumeAdjustment() float32 {
	if x != nil && x.VolumeAdjustment != nil {
		return *x.VolumeAdjustment
	}
	return 0
}

type BanList_BanEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Banned IP address.
	Address []byte `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	// The length of the subnet mask for the ban.
	Mask *uint32 `protobuf:"varint,2,req,name=mask" json:"mask,omitempty"`
	// User name for identification purposes (does not affect the ban).
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The certificate hash of the banned user.
	Hash *string `protobuf:"bytes,4,opt,name=hash" json:"hash,omitempty"`
	// Reason for the ban (does not affect the ban).
	Reason *string `protobuf:"bytes,5,opt,name=reason" json:"reason,omitempty"`
	// Ban start time.
	Start *string `protobuf:"bytes,6,opt,name=start" json:"start,omitempty"`
	// Ban duration in seconds.
	Duration      *uint32 `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BanList_BanEntry) Reset() {
	*x = BanList_BanEntry{}
	mi := &file_MumbleTCP_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BanList_BanEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BanList_BanEntry) ProtoMessage() {}

func (x *BanList_BanEntry) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BanList_BanEntry.ProtoReflect.Descriptor instead.
func (*BanList_BanEntry) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{10, 0}
}

func (x *BanList_BanEntry) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *BanList_BanEntry) GetMask() uint32 {
	if x != nil && x.Mask != nil {
		return *x.Mask
	}
	return 0
}

func (x *BanList_BanEntry) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *BanList_BanEntry) GetHash() string {
	if x != nil && x.Hash != nil {
		return *x.Hash
	}
	return ""
}

func (x *BanList_BanEntry) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *BanList_BanEntry) GetStart() string {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return ""
}

func (x *BanList_BanEntry) GetDuration() uint32 {
	if x != nil && x.Duration != nil {
		return *x.Duration
	}
	return 0
}

type ACL_ChanGroup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the channel group, UTF-8 encoded.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// True if the group has been inherited from the parent (Read only).
	Inherited *bool `protobuf:"varint,2,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// True if the group members are inherited.
	Inherit *bool `protobuf:"varint,3,opt,name=inherit,def=1" json:"inherit,omitempty"`
	// True if the group can be inherited by sub channels.
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable,def=1" json:"inheritable,omitempty"`
	// Users explicitly included in this group, identified by user_id.
	Add []uint32 `protobuf:"varint,5,rep,name=add" json:"add,omitempty"`
	// Users explicitly removed from this group in this channel if the group
	// has been inherited, identified by user_id.
	Remove []uint32 `protobuf:"varint,6,rep,name=remove" json:"remove,omitempty"`
	// Users inherited, identified by user_id.
	InheritedMembers []uint32 `protobuf:"varint,7,rep,name=inherited_members,json=inheritedMembers" json:"inherited_members,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

// Default values for ACL_ChanGroup fields.
const (
	Default_ACL_ChanGroup_Inherited   = bool(true)
	Default_ACL_ChanGroup_Inherit     = bool(true)
	Default_ACL_ChanGroup_Inheritable = bool(true)
)

func (x *ACL_ChanGroup) Reset() {
	*x = ACL_ChanGroup{}
	mi := &file_MumbleTCP_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACL_ChanGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACL_ChanGroup) ProtoMessage() {}

func (x *ACL_ChanGroup) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACL_ChanGroup.ProtoReflect.Descriptor instead.
func (*ACL_ChanGroup) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{13, 0}
}

func (x *ACL_ChanGroup) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ACL_ChanGroup) GetInherited() bool {
	if x != nil && x.Inherited != nil {
		return *x.Inherited
	}
	return Default_ACL_ChanGroup_Inherited
}

func (x *ACL_ChanGroup) GetInherit() bool {
	if x != nil && x.Inherit != nil {
		return *x.Inherit
	}
	return Default_ACL_ChanGroup_Inherit
}

func (x *ACL_ChanGroup) GetInheritable() bool {
	if x != nil && x.Inheritable != nil {
		return *x.Inheritable
	}
	return Default_ACL_ChanGroup_Inheritable
}

func (x *ACL_ChanGroup) GetAdd() []uint32 {
	if x != nil {
		return x.Add
	}
	return nil
}

func (x *ACL_ChanGroup) GetRemove() []uint32 {
	if x != nil {
		return x.Remove
	}
	return nil
}

func (x *ACL_ChanGroup) GetInheritedMembers() []uint32 {
	if x != nil {
		return x.InheritedMembers
	}
	return nil
}

type ACL_ChanACL struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// True if this ACL applies to the current channel.
	ApplyHere *bool `protobuf:"varint,1,opt,name=apply_here,json=applyHere,def=1" json:"apply_here,omitempty"`
	// True if this ACL applies to the sub channels.
	ApplySubs *bool `protobuf:"varint,2,opt,name=apply_subs,json=applySubs,def=1" json:"apply_subs,omitempty"`
	// True if the ACL has been inherited from the parent.
	Inherited *bool `protobuf:"varint,3,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// ID of the user that is affected by this ACL.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// ID of the group that is affected by this ACL.
	Group *string `protobuf:"bytes,5,opt,name=group" json:"group,omitempty"`
	// Bit flag field of the permissions granted by this ACL.
	Grant *uint32 `protobuf:"varint,6,opt,name=grant" json:"grant,omitempty"`
	// Bit flag field of the permissions denied by this ACL.
	Deny          *uint32 `protobuf:"varint,7,opt,name=deny" json:"deny,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for ACL_ChanACL fields.
const (
	Default_ACL_ChanACL_ApplyHere = bool(true)
	Default_ACL_ChanACL_ApplySubs = bool(true)
	Default_ACL_ChanACL_Inherited = bool(true)
)

func (x *ACL_ChanACL) Reset() {
	*x = ACL_ChanACL{}
	mi := &file_MumbleTCP_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACL_ChanACL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACL_ChanACL) ProtoMessage() {}

func (x *ACL_ChanACL) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACL_ChanACL.ProtoReflect.Descriptor instead.
func (*ACL_ChanACL) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{13, 1}
}

func (x *ACL_ChanACL) GetApplyHere() bool {
	if x != nil && x.ApplyHere != nil {
		return *x.ApplyHere
	}
	return Default_ACL_ChanACL_ApplyHere
}

func (x *ACL_ChanACL) GetApplySubs() bool {
	if x != nil && x.ApplySubs != nil {
		return *x.ApplySubs
	}
	return Default_ACL_ChanACL_ApplySubs
}

func (x *ACL_ChanACL) GetInherited() bool {
	if x != nil && x.Inherited != nil {
		return *x.Inherited
	}
	return Default_ACL_ChanACL_Inherited
}

func (x *ACL_ChanACL) GetUserId() uint32 {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return 0
}

func (x *ACL_ChanACL) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *ACL_ChanACL) GetGrant() uint32 {
	if x != nil && x.Grant != nil {
		return *x.Grant
	}
	return 0
}

func (x *ACL_ChanACL) GetDeny() uint32 {
	if x != nil && x.Deny != nil {
		return *x.Deny
	}
	return 0
}

type UserList_User struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Registered user ID.
	UserId *uint32 `protobuf:"varint,1,req,name=user_id,json=userId" json:"user_id,omitempty"`
	// Registered user name.
	Name          *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	LastSeen      *string `protobuf:"bytes,3,opt,name=last_seen,json=lastSeen" json:"last_seen,omitempty"`
	LastChannel   *uint32 `protobuf:"varint,4,opt,name=last_channel,json=lastChannel" json:"last_channel,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserList_User) Reset() {
	*x = UserList_User{}
	mi := &file_MumbleTCP_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserList_User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserList_User) ProtoMessage() {}

func (x *UserList_User) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserList_User.ProtoReflect.Descriptor instead.
func (*UserList_User) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{18, 0}
}

func (x *UserList_User) GetUserId() uint32 {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return 0
}

func (x *UserList_User) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *UserList_User) GetLastSeen() string {
	if x != nil && x.LastSeen != nil {
		return *x.LastSeen
	}
	return ""
}

func (x *UserList_User) GetLastChannel() uint32 {
	if x != nil && x.LastChannel != nil {
		return *x.LastChannel
	}
	return 0
}

type VoiceTarget_Target struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Users that are included as targets.
	Session []uint32 `protobuf:"varint,1,rep,name=session" json:"session,omitempty"`
	// Channel that is included as a target.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// ACL group that is included as a target.
	Group *string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	// True if the voice should follow links from the specified channel.
	Links *bool `protobuf:"varint,4,opt,name=links,def=0" json:"links,omitempty"`
	// True if the voice should also be sent to children of the specific
	// channel.
	Children      *bool `protobuf:"varint,5,opt,name=children,def=0" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for VoiceTarget_Target fields.
const (
	Default_VoiceTarget_Target_Links    = bool(false)
	Default_VoiceTarget_Target_Children = bool(false)
)

func (x *VoiceTarget_Target) Reset() {
	*x = VoiceTarget_Target{}
	mi := &file_MumbleTCP_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VoiceTarget_Target) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VoiceTarget_Target) ProtoMessage() {}

func (x *VoiceTarget_Target) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VoiceTarget_Target.ProtoReflect.Descriptor instead.
func (*VoiceTarget_Target) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{19, 0}
}

func (x *VoiceTarget_Target) GetSession() []uint32 {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *VoiceTarget_Target) GetChannelId() uint32 {
	if x != nil && x.ChannelId != nil {
		return *x.ChannelId
	}
	return 0
}

func (x *VoiceTarget_Target) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *VoiceTarget_Target) GetLinks() bool {
	if x != nil && x.Links != nil {
		return *x.Links
	}
	return Default_VoiceTarget_Target_Links
}

func (x *VoiceTarget_Target) GetChildren() bool {
	if x != nil && x.Children != nil {
		return *x.Children
	}
	return Default_VoiceTarget_Target_Children
}

type UserStats_Stats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,1,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,2,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,3,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync        *uint32 `protobuf:"varint,4,opt,name=resync" json:"resync,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserStats_Stats) Reset() {
	*x = UserStats_Stats{}
	mi := &file_MumbleTCP_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserStats_Stats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStats_Stats) ProtoMessage() {}

func (x *UserStats_Stats) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStats_Stats.ProtoReflect.Descriptor instead.
func (*UserStats_Stats) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{22, 0}
}

func (x *UserStats_Stats) GetGood() uint32 {
	if x != nil && x.Good != nil {
		return *x.Good
	}
	return 0
}

func (x *UserStats_Stats) GetLate() uint32 {
	if x != nil && x.Late != nil {
		return *x.Late
	}
	return 0
}

func (x *UserStats_Stats) GetLost() uint32 {
	if x != nil && x.Lost != nil {
		return *x.Lost
	}
	return 0
}

func (x *UserStats_Stats) GetResync() uint32 {
	if x != nil && x.Resync != nil {
		return *x.Resync
	}
	return 0
}

type UserStats_RollingStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Rolling packet statistics time window as defined on the server.
	TimeWindow *uint32 `protobuf:"varint,1,opt,name=time_window,json=timeWindow" json:"time_window,omitempty"`
	// Rolling packet statistics for packets received from the client.
	FromClient *UserStats_Stats `protobuf:"bytes,2,opt,name=from_client,json=fromClient" json:"from_client,omitempty"`
	// Rolling packet statistics for packets sent by the server.
	FromServer    *UserStats_Stats `protobuf:"bytes,3,opt,name=from_server,json=fromServer" json:"from_server,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserStats_RollingStats) Reset() {
	*x = UserStats_RollingStats{}
	mi := &file_MumbleTCP_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserStats_RollingStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStats_RollingStats) ProtoMessage() {}

func (x *UserStats_RollingStats) ProtoReflect() protoreflect.Message {
	mi := &file_MumbleTCP_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStats_RollingStats.ProtoReflect.Descriptor instead.
func (*UserStats_RollingStats) Descriptor() ([]byte, []int) {
	return file_MumbleTCP_proto_rawDescGZIP(), []int{22, 1}
}

func (x *UserStats_RollingStats) GetTimeWindow() uint32 {
	if x != nil && x.TimeWindow != nil {
		return *x.TimeWindow
	}
	return 0
}

func (x *UserStats_RollingStats) GetFromClient() *UserStats_Stats {
	if x != nil {
		return x.FromClient
	}
	return nil
}

func (x *UserStats_RollingStats) GetFromServer() *UserStats_Stats {
	if x != nil {
		return x.FromServer
	}
	return nil
}

var File_MumbleTCP_proto protoreflect.FileDescriptor

const file_MumbleTCP_proto_rawDesc = "" +
	"\n" +
	"\x0fMumbleTCP.proto\x12\vMumbleProto\"\x90\x01\n" +
	"\aVersion\x12\x1d\n" +
	"\n" +
	"version_v1\x18\x01 \x01(\rR\tversionV1\x12\x1d\n" +
	"\n" +
	"version_v2\x18\x05 \x01(\x04R\tversionV2\x12\x18\n" +
	"\arelease\x18\x02 \x01(\tR\arelease\x12\x0e\n" +
	"\x02os\x18\x03 \x01(\tR\x02os\x12\x1d\n" +
	"\n" +
	"os_version\x18\x04 \x01(\tR\tosVersion\"#\n" +
	"\tUDPTunnel\x12\x16\n" +
	"\x06packet\x18\x01 \x02(\fR\x06packet\"\xc2\x01\n" +
	"\fAuthenticate\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\x12\x16\n" +
	"\x06tokens\x18\x03 \x03(\tR\x06tokens\x12#\n" +
	"\rcelt_versions\x18\x04 \x03(\x05R\fceltVersions\x12\x19\n" +
	"\x04opus\x18\x05 \x01(\b:\x05falseR\x04opus\x12\"\n" +
	"\vclient_type\x18\x06 \x01(\x05:\x010R\n" +
	"clientType\"\xc2\x02\n" +
	"\x04Ping\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x04R\ttimestamp\x12\x12\n" +
	"\x04good\x18\x02 \x01(\rR\x04good\x12\x12\n" +
	"\x04late\x18\x03 \x01(\rR\x04late\x12\x12\n" +
	"\x04lost\x18\x04 \x01(\rR\x04lost\x12\x16\n" +
	"\x06resync\x18\x05 \x01(\rR\x06resync\x12\x1f\n" +
	"\vudp_packets\x18\x06 \x01(\rR\n" +
	"udpPackets\x12\x1f\n" +
	"\vtcp_packets\x18\a \x01(\rR\n" +
	"tcpPackets\x12 \n" +
	"\fudp_ping_avg\x18\b \x01(\x02R\n" +
	"udpPingAvg\x12 \n" +
	"\fudp_ping_var\x18\t \x01(\x02R\n" +
	"udpPingVar\x12 \n" +
	"\ftcp_ping_avg\x18\n" +
	" \x01(\x02R\n" +
	"tcpPingAvg\x12 \n" +
	"\ftcp_ping_var\x18\v \x01(\x02R\n" +
	"tcpPingVar\"\x9b\x02\n" +
	"\x06Reject\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.MumbleProto.Reject.RejectTypeR\x04type\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"\xc4\x01\n" +
	"\n" +
	"RejectType\x12\b\n" +
	"\x04None\x10\x00\x12\x10\n" +
	"\fWrongVersion\x10\x01\x12\x13\n" +
	"\x0fInvalidUsername\x10\x02\x12\x0f\n" +
	"\vWrongUserPW\x10\x03\x12\x11\n" +
	"\rWrongServerPW\x10\x04\x12\x11\n" +
	"\rUsernameInUse\x10\x05\x12\x0e\n" +
	"\n" +
	"ServerFull\x10\x06\x12\x11\n" +
	"\rNoCertificate\x10\a\x12\x15\n" +
	"\x11AuthenticatorFail\x10\b\x12\x14\n" +
	"\x10NoNewConnections\x10\t\"\x90\x01\n" +
	"\n" +
	"ServerSync\x12\x18\n" +
	"\asession\x18\x01 \x01(\rR\asession\x12#\n" +
	"\rmax_bandwidth\x18\x02 \x01(\rR\fmaxBandwidth\x12!\n" +
	"\fwelcome_text\x18\x03 \x01(\tR\vwelcomeText\x12 \n" +
	"\vpermissions\x18\x04 \x01(\x04R\vpermissions\".\n" +
	"\rChannelRemove\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x02(\rR\tchannelId\"\xaa\x03\n" +
	"\fChannelState\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\rR\tchannelId\x12\x16\n" +
	"\x06parent\x18\x02 \x01(\rR\x06parent\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x14\n" +
	"\x05links\x18\x04 \x03(\rR\x05links\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x1b\n" +
	"\tlinks_add\x18\x06 \x03(\rR\blinksAdd\x12!\n" +
	"\flinks_remove\x18\a \x03(\rR\vlinksRemove\x12#\n" +
	"\ttemporary\x18\b \x01(\b:\x05falseR\ttemporary\x12\x1d\n" +
	"\bposition\x18\t \x01(\x05:\x010R\bposition\x12)\n" +
	"\x10description_hash\x18\n" +
	" \x01(\fR\x0fdescriptionHash\x12\x1b\n" +
	"\tmax_users\x18\v \x01(\rR\bmaxUsers\x12.\n" +
	"\x13is_enter_restricted\x18\f \x01(\bR\x11isEnterRestricted\x12\x1b\n" +
	"\tcan_enter\x18\r \x01(\bR\bcanEnter\"f\n" +
	"\n" +
	"UserRemove\x12\x18\n" +
	"\asession\x18\x01 \x02(\rR\asession\x12\x14\n" +
	"\x05actor\x18\x02 \x01(\rR\x05actor\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\x12\x10\n" +
	"\x03ban\x18\x04 \x01(\bR\x03ban\"\xa9\a\n" +
	"\tUserState\x12\x18\n" +
	"\asession\x18\x01 \x01(\rR\asession\x12\x14\n" +
	"\x05actor\x18\x02 \x01(\rR\x05actor\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\rR\x06userId\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x05 \x01(\rR\tchannelId\x12\x12\n" +
	"\x04mute\x18\x06 \x01(\bR\x04mute\x12\x12\n" +
	"\x04deaf\x18\a \x01(\bR\x04deaf\x12\x1a\n" +
	"\bsuppress\x18\b \x01(\bR\bsuppress\x12\x1b\n" +
	"\tself_mute\x18\t \x01(\bR\bselfMute\x12\x1b\n" +
	"\tself_deaf\x18\n" +
	" \x01(\bR\bselfDeaf\x12\x18\n" +
	"\atexture\x18\v \x01(\fR\atexture\x12%\n" +
	"\x0eplugin_context\x18\f \x01(\fR\rpluginContext\x12'\n" +
	"\x0fplugin_identity\x18\r \x01(\tR\x0epluginIdentity\x12\x18\n" +
	"\acomment\x18\x0e \x01(\tR\acomment\x12\x12\n" +
	"\x04hash\x18\x0f \x01(\tR\x04hash\x12!\n" +
	"\fcomment_hash\x18\x10 \x01(\fR\vcommentHash\x12!\n" +
	"\ftexture_hash\x18\x11 \x01(\fR\vtextureHash\x12)\n" +
	"\x10priority_speaker\x18\x12 \x01(\bR\x0fprioritySpeaker\x12\x1c\n" +
	"\trecording\x18\x13 \x01(\bR\trecording\x126\n" +
	"\x17temporary_access_tokens\x18\x14 \x03(\tR\x15temporaryAccessTokens\x122\n" +
	"\x15listening_channel_add\x18\x15 \x03(\rR\x13listeningChannelAdd\x128\n" +
	"\x18listening_channel_remove\x18\x16 \x03(\rR\x16listeningChannelRemove\x12g\n" +
	"\x1blistening_volume_adjustment\x18\x17 \x03(\v2'.MumbleProto.UserState.VolumeAdjustmentR\x19listeningVolumeAdjustment\x1al\n" +
	"\x10VolumeAdjustment\x12+\n" +
	"\x11listening_channel\x18\x01 \x01(\rR\x10listeningChannel\x12+\n" +
	"\x11volume_adjustment\x18\x02 \x01(\x02R\x10volumeAdjustment\"\x86\x02\n" +
	"\aBanList\x121\n" +
	"\x04bans\x18\x01 \x03(\v2\x1d.MumbleProto.BanList.BanEntryR\x04bans\x12\x1b\n" +
	"\x05query\x18\x02 \x01(\b:\x05falseR\x05query\x1a\xaa\x01\n" +
	"\bBanEntry\x12\x18\n" +
	"\aaddress\x18\x01 \x02(\fR\aaddress\x12\x12\n" +
	"\x04mask\x18\x02 \x02(\rR\x04mask\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x12\n" +
	"\x04hash\x18\x04 \x01(\tR\x04hash\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\x12\x14\n" +
	"\x05start\x18\x06 \x01(\tR\x05start\x12\x1a\n" +
	"\bduration\x18\a \x01(\rR\bduration\"\x8f\x01\n" +
	"\vTextMessage\x12\x14\n" +
	"\x05actor\x18\x01 \x01(\rR\x05actor\x12\x18\n" +
	"\asession\x18\x02 \x03(\rR\asession\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x03 \x03(\rR\tchannelId\x12\x17\n" +
	"\atree_id\x18\x04 \x03(\rR\x06treeId\x12\x18\n" +
	"\amessage\x18\x05 \x02(\tR\amessage\"\xdb\x03\n" +
	"\x10PermissionDenied\x12\x1e\n" +
	"\n" +
	"permission\x18\x01 \x01(\rR\n" +
	"permission\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x02 \x01(\rR\tchannelId\x12\x18\n" +
	"\asession\x18\x03 \x01(\rR\asession\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\x12:\n" +
	"\x04type\x18\x05 \x01(\x0e2&.MumbleProto.PermissionDenied.DenyTypeR\x04type\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\"\x85\x02\n" +
	"\bDenyType\x12\b\n" +
	"\x04Text\x10\x00\x12\x0e\n" +
	"\n" +
	"Permission\x10\x01\x12\r\n" +
	"\tSuperUser\x10\x02\x12\x0f\n" +
	"\vChannelName\x10\x03\x12\x0f\n" +
	"\vTextTooLong\x10\x04\x12\a\n" +
	"\x03H9K\x10\x05\x12\x14\n" +
	"\x10TemporaryChannel\x10\x06\x12\x16\n" +
	"\x12MissingCertificate\x10\a\x12\f\n" +
	"\bUserName\x10\b\x12\x0f\n" +
	"\vChannelFull\x10\t\x12\x10\n" +
	"\fNestingLimit\x10\n" +
	"\x12\x15\n" +
	"\x11ChannelCountLimit\x10\v\x12\x18\n" +
	"\x14ChannelListenerLimit\x10\f\x12\x15\n" +
	"\x11UserListenerLimit\x10\r\"\x84\x05\n" +
	"\x03ACL\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x02(\rR\tchannelId\x12'\n" +
	"\finherit_acls\x18\x02 \x01(\b:\x04trueR\vinheritAcls\x122\n" +
	"\x06groups\x18\x03 \x03(\v2\x1a.MumbleProto.ACL.ChanGroupR\x06groups\x12,\n" +
	"\x04acls\x18\x04 \x03(\v2\x18.MumbleProto.ACL.ChanACLR\x04acls\x12\x1b\n" +
	"\x05query\x18\x05 \x01(\b:\x05falseR\x05query\x1a\xe2\x01\n" +
	"\tChanGroup\x12\x12\n" +
	"\x04name\x18\x01 \x02(\tR\x04name\x12\"\n" +
	"\tinherited\x18\x02 \x01(\b:\x04trueR\tinherited\x12\x1e\n" +
	"\ainherit\x18\x03 \x01(\b:\x04trueR\ainherit\x12&\n" +
	"\vinheritable\x18\x04 \x01(\b:\x04trueR\vinheritable\x12\x10\n" +
	"\x03add\x18\x05 \x03(\rR\x03add\x12\x16\n" +
	"\x06remove\x18\x06 \x03(\rR\x06remove\x12+\n" +
	"\x11inherited_members\x18\a \x03(\rR\x10inheritedMembers\x1a\xd0\x01\n" +
	"\aChanACL\x12#\n" +
	"\n" +
	"apply_here\x18\x01 \x01(\b:\x04trueR\tapplyHere\x12#\n" +
	"\n" +
	"apply_subs\x18\x02 \x01(\b:\x04trueR\tapplySubs\x12\"\n" +
	"\tinherited\x18\x03 \x01(\b:\x04trueR\tinherited\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\rR\x06userId\x12\x14\n" +
	"\x05group\x18\x05 \x01(\tR\x05group\x12\x14\n" +
	"\x05grant\x18\x06 \x01(\rR\x05grant\x12\x12\n" +
	"\x04deny\x18\a \x01(\rR\x04deny\"4\n" +
	"\n" +
	"QueryUsers\x12\x10\n" +
	"\x03ids\x18\x01 \x03(\rR\x03ids\x12\x14\n" +
	"\x05names\x18\x02 \x03(\tR\x05names\"d\n" +
	"\n" +
	"CryptSetup\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12!\n" +
	"\fclient_nonce\x18\x02 \x01(\fR\vclientNonce\x12!\n" +
	"\fserver_nonce\x18\x03 \x01(\fR\vserverNonce\"\xf5\x01\n" +
	"\x13ContextActionModify\x12\x16\n" +
	"\x06action\x18\x01 \x02(\tR\x06action\x12\x12\n" +
	"\x04text\x18\x02 \x01(\tR\x04text\x12\x18\n" +
	"\acontext\x18\x03 \x01(\rR\acontext\x12H\n" +
	"\toperation\x18\x04 \x01(\x0e2*.MumbleProto.ContextActionModify.OperationR\toperation\",\n" +
	"\aContext\x12\n" +
	"\n" +
	"\x06Server\x10\x01\x12\v\n" +
	"\aChannel\x10\x02\x12\b\n" +
	"\x04User\x10\x04\" \n" +
	"\tOperation\x12\a\n" +
	"\x03Add\x10\x00\x12\n" +
	"\n" +
	"\x06Remove\x10\x01\"`\n" +
	"\rContextAction\x12\x18\n" +
	"\asession\x18\x01 \x01(\rR\asession\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x02 \x01(\rR\tchannelId\x12\x16\n" +
	"\x06action\x18\x03 \x02(\tR\x06action\"\xb1\x01\n" +
	"\bUserList\x120\n" +
	"\x05users\x18\x01 \x03(\v2\x1a.MumbleProto.UserList.UserR\x05users\x1as\n" +
	"\x04User\x12\x17\n" +
	"\auser_id\x18\x01 \x02(\rR\x06userId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1b\n" +
	"\tlast_seen\x18\x03 \x01(\tR\blastSeen\x12!\n" +
	"\flast_channel\x18\x04 \x01(\rR\vlastChannel\"\xf2\x01\n" +
	"\vVoiceTarget\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x129\n" +
	"\atargets\x18\x02 \x03(\v2\x1f.MumbleProto.VoiceTarget.TargetR\atargets\x1a\x97\x01\n" +
	"\x06Target\x12\x18\n" +
	"\asession\x18\x01 \x03(\rR\asession\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x02 \x01(\rR\tchannelId\x12\x14\n" +
	"\x05group\x18\x03 \x01(\tR\x05group\x12\x1b\n" +
	"\x05links\x18\x04 \x01(\b:\x05falseR\x05links\x12!\n" +
	"\bchildren\x18\x05 \x01(\b:\x05falseR\bchildren\"o\n" +
	"\x0fPermissionQuery\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\rR\tchannelId\x12 \n" +
	"\vpermissions\x18\x02 \x01(\rR\vpermissions\x12\x1b\n" +
	"\x05flush\x18\x03 \x01(\b:\x05falseR\x05flush\"|\n" +
	"\fCodecVersion\x12\x14\n" +
	"\x05alpha\x18\x01 \x02(\x05R\x05alpha\x12\x12\n" +
	"\x04beta\x18\x02 \x02(\x05R\x04beta\x12'\n" +
	"\fprefer_alpha\x18\x03 \x02(\b:\x04trueR\vpreferAlpha\x12\x19\n" +
	"\x04opus\x18\x04 \x01(\b:\x05falseR\x04opus\"\xa8\b\n" +
	"\tUserStats\x12\x18\n" +
	"\asession\x18\x01 \x01(\rR\asession\x12$\n" +
	"\n" +
	"stats_only\x18\x02 \x01(\b:\x05falseR\tstatsOnly\x12\"\n" +
	"\fcertificates\x18\x03 \x03(\fR\fcertificates\x12=\n" +
	"\vfrom_client\x18\x04 \x01(\v2\x1c.MumbleProto.UserStats.StatsR\n" +
	"fromClient\x12=\n" +
	"\vfrom_server\x18\x05 \x01(\v2\x1c.MumbleProto.UserStats.StatsR\n" +
	"fromServer\x12\x1f\n" +
	"\vudp_packets\x18\x06 \x01(\rR\n" +
	"udpPackets\x12\x1f\n" +
	"\vtcp_packets\x18\a \x01(\rR\n" +
	"tcpPackets\x12 \n" +
	"\fudp_ping_avg\x18\b \x01(\x02R\n" +
	"udpPingAvg\x12 \n" +
	"\fudp_ping_var\x18\t \x01(\x02R\n" +
	"udpPingVar\x12 \n" +
	"\ftcp_ping_avg\x18\n" +
	" \x01(\x02R\n" +
	"tcpPingAvg\x12 \n" +
	"\ftcp_ping_var\x18\v \x01(\x02R\n" +
	"tcpPingVar\x12.\n" +
	"\aversion\x18\f \x01(\v2\x14.MumbleProto.VersionR\aversion\x12#\n" +
	"\rcelt_versions\x18\r \x03(\x05R\fceltVersions\x12\x18\n" +
	"\aaddress\x18\x0e \x01(\fR\aaddress\x12\x1c\n" +
	"\tbandwidth\x18\x0f \x01(\rR\tbandwidth\x12\x1e\n" +
	"\n" +
	"onlinesecs\x18\x10 \x01(\rR\n" +
	"onlinesecs\x12\x1a\n" +
	"\bidlesecs\x18\x11 \x01(\rR\bidlesecs\x124\n" +
	"\x12strong_certificate\x18\x12 \x01(\b:\x05falseR\x11strongCertificate\x12\x19\n" +
	"\x04opus\x18\x13 \x01(\b:\x05falseR\x04opus\x12H\n" +
	"\rrolling_stats\x18\x14 \x01(\v2#.MumbleProto.UserStats.RollingStatsR\frollingStats\x1a[\n" +
	"\x05Stats\x12\x12\n" +
	"\x04good\x18\x01 \x01(\rR\x04good\x12\x12\n" +
	"\x04late\x18\x02 \x01(\rR\x04late\x12\x12\n" +
	"\x04lost\x18\x03 \x01(\rR\x04lost\x12\x16\n" +
	"\x06resync\x18\x04 \x01(\rR\x06resync\x1a\xad\x01\n" +
	"\fRollingStats\x12\x1f\n" +
	"\vtime_window\x18\x01 \x01(\rR\n" +
	"timeWindow\x12=\n" +
	"\vfrom_client\x18\x02 \x01(\v2\x1c.MumbleProto.UserStats.StatsR\n" +
	"fromClient\x12=\n" +
	"\vfrom_server\x18\x03 \x01(\v2\x1c.MumbleProto.UserStats.StatsR\n" +
	"fromServer\"\x90\x01\n" +
	"\vRequestBlob\x12'\n" +
	"\x0fsession_texture\x18\x01 \x03(\rR\x0esessionTexture\x12'\n" +
	"\x0fsession_comment\x18\x02 \x03(\rR\x0esessionComment\x12/\n" +
	"\x13channel_description\x18\x03 \x03(\rR\x12channelDescription\"\x98\x02\n" +
	"\fServerConfig\x12#\n" +
	"\rmax_bandwidth\x18\x01 \x01(\rR\fmaxBandwidth\x12!\n" +
	"\fwelcome_text\x18\x02 \x01(\tR\vwelcomeText\x12\x1d\n" +
	"\n" +
	"allow_html\x18\x03 \x01(\bR\tallowHtml\x12%\n" +
	"\x0emessage_length\x18\x04 \x01(\rR\rmessageLength\x120\n" +
	"\x14image_message_length\x18\x05 \x01(\rR\x12imageMessageLength\x12\x1b\n" +
	"\tmax_users\x18\x06 \x01(\rR\bmaxUsers\x12+\n" +
	"\x11recording_allowed\x18\a \x01(\bR\x10recordingAllowed\"\x8f\x01\n" +
	"\rSuggestConfig\x12\x1d\n" +
	"\n" +
	"version_v1\x18\x01 \x01(\rR\tversionV1\x12\x1d\n" +
	"\n" +
	"version_v2\x18\x04 \x01(\x04R\tversionV2\x12\x1e\n" +
	"\n" +
	"positional\x18\x02 \x01(\bR\n" +
	"positional\x12 \n" +
	"\fpush_to_talk\x18\x03 \x01(\bR\n" +
	"pushToTalk\"\x9a\x01\n" +
	"\x16PluginDataTransmission\x12$\n" +
	"\rsenderSession\x18\x01 \x01(\rR\rsenderSession\x12.\n" +
	"\x10receiverSessions\x18\x02 \x03(\rB\x02\x10\x01R\x10receiverSessions\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x16\n" +
	"\x06dataID\x18\x04 \x01(\tR\x06dataIDB\x10H\x01Z\f/mumbleproto"

var (
	file_MumbleTCP_proto_rawDescOnce sync.Once
	file_MumbleTCP_proto_rawDescData []byte
)

func file_MumbleTCP_proto_rawDescGZIP() []byte {
	file_MumbleTCP_proto_rawDescOnce.Do(func() {
		file_MumbleTCP_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_MumbleTCP_proto_rawDesc), len(file_MumbleTCP_proto_rawDesc)))
	})
	return file_MumbleTCP_proto_rawDescData
}

var file_MumbleTCP_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_MumbleTCP_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_MumbleTCP_proto_goTypes = []any{
	(Reject_RejectType)(0),             // 0: MumbleProto.Reject.RejectType
	(PermissionDenied_DenyType)(0),     // 1: MumbleProto.PermissionDenied.DenyType
	(ContextActionModify_Context)(0),   // 2: MumbleProto.ContextActionModify.Context
	(ContextActionModify_Operation)(0), // 3: MumbleProto.ContextActionModify.Operation
	(*Version)(nil),                    // 4: MumbleProto.Version
	(*UDPTunnel)(nil),                  // 5: MumbleProto.UDPTunnel
	(*Authenticate)(nil),               // 6: MumbleProto.Authenticate
	(*Ping)(nil),                       // 7: MumbleProto.Ping
	(*Reject)(nil),                     // 8: MumbleProto.Reject
	(*ServerSync)(nil),                 // 9: MumbleProto.ServerSync
	(*ChannelRemove)(nil),              // 10: MumbleProto.ChannelRemove
	(*ChannelState)(nil),               // 11: MumbleProto.ChannelState
	(*UserRemove)(nil),                 // 12: MumbleProto.UserRemove
	(*UserState)(nil),                  // 13: MumbleProto.UserState
	(*BanList)(nil),                    // 14: MumbleProto.BanList
	(*TextMessage)(nil),                // 15: MumbleProto.TextMessage
	(*PermissionDenied)(nil),           // 16: MumbleProto.PermissionDenied
	(*ACL)(nil),                        // 17: MumbleProto.ACL
	(*QueryUsers)(nil),                 // 18: MumbleProto.QueryUsers
	(*CryptSetup)(nil),                 // 19: MumbleProto.CryptSetup
	(*ContextActionModify)(nil),        // 20: MumbleProto.ContextActionModify
	(*ContextAction)(nil),              // 21: MumbleProto.ContextAction
	(*UserList)(nil),                   // 22: MumbleProto.UserList
	(*VoiceTarget)(nil),                // 23: MumbleProto.VoiceTarget
	(*PermissionQuery)(nil),            // 24: MumbleProto.PermissionQuery
	(*CodecVersion)(nil),               // 25: MumbleProto.CodecVersion
	(*UserStats)(nil),                  // 26: MumbleProto.UserStats
	(*RequestBlob)(nil),                // 27: MumbleProto.RequestBlob
	(*ServerConfig)(nil),               // 28: MumbleProto.ServerConfig
	(*SuggestConfig)(nil),              // 29: MumbleProto.SuggestConfig
	(*PluginDataTransmission)(nil),     // 30: MumbleProto.PluginDataTransmission
	(*UserState_VolumeAdjustment)(nil), // 31: MumbleProto.UserState.VolumeAdjustment
	(*BanList_BanEntry)(nil),           // 32: MumbleProto.BanList.BanEntry
	(*ACL_ChanGroup)(nil),              // 33: MumbleProto.ACL.ChanGroup
	(*ACL_ChanACL)(nil),                // 34: MumbleProto.ACL.ChanACL
	(*UserList_User)(nil),              // 35: MumbleProto.UserList.User
	(*VoiceTarget_Target)(nil),         // 36: MumbleProto.VoiceTarget.Target
	(*UserStats_Stats)(nil),            // 37: MumbleProto.UserStats.Stats
	(*UserStats_RollingStats)(nil),     // 38: MumbleProto.UserStats.RollingStats
}
var file_MumbleTCP_proto_depIdxs = []int32{
	0,  // 0: MumbleProto.Reject.type:type_name -> MumbleProto.Reject.RejectType
	31, // 1: MumbleProto.UserState.listening_volume_adjustment:type_name -> MumbleProto.UserState.VolumeAdjustment
	32, // 2: MumbleProto.BanList.bans:type_name -> MumbleProto.BanList.BanEntry
	1,  // 3: MumbleProto.PermissionDenied.type:type_name -> MumbleProto.PermissionDenied.DenyType
	33, // 4: MumbleProto.ACL.groups:type_name -> MumbleProto.ACL.ChanGroup
	34, // 5: MumbleProto.ACL.acls:type_name -> MumbleProto.ACL.ChanACL
	3,  // 6: MumbleProto.ContextActionModify.operation:type_name -> MumbleProto.ContextActionModify.Operation
	35, // 7: MumbleProto.UserList.users:type_name -> MumbleProto.UserList.User
	36, // 8: MumbleProto.VoiceTarget.targets:type_name -> MumbleProto.VoiceTarget.Target
	37, // 9: MumbleProto.UserStats.from_client:type_name -> MumbleProto.UserStats.Stats
	37, // 10: MumbleProto.UserStats.from_server:type_name -> MumbleProto.UserStats.Stats
	4,  // 11: MumbleProto.UserStats.version:type_name -> MumbleProto.Version
	38, // 12: MumbleProto.UserStats.rolling_stats:type_name -> MumbleProto.UserStats.RollingStats
	37, // 13: MumbleProto.UserStats.RollingStats.from_client:type_name -> MumbleProto.UserStats.Stats
	37, // 14: MumbleProto.UserStats.RollingStats.from_server:type_name -> MumbleProto.UserStats.Stats
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_MumbleTCP_proto_init() }
func file_MumbleTCP_proto_init() {
	if File_MumbleTCP_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_MumbleTCP_proto_rawDesc), len(file_MumbleTCP_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   35,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_MumbleTCP_proto_goTypes,
		DependencyIndexes: file_MumbleTCP_proto_depIdxs,
		EnumInfos:         file_MumbleTCP_proto_enumTypes,
		MessageInfos:      file_MumbleTCP_proto_msgTypes,
	}.Build()
	File_MumbleTCP_proto = out.File
	file_MumbleTCP_proto_goTypes = nil
	file_MumbleTCP_proto_depIdxs = nil
}
